在 Linux 中运行脚本时，默认的工作路径是调用脚本时所在的目录，但可以通过以下方法改变这一点：

---

### **方法一：在脚本内部切换目录**
在脚本开头使用 `cd` 命令直接切换路径：
```bash
#!/bin/bash
cd /目标路径    # 后续命令将在 /目标路径 下执行
# 其他操作...
```
**注意**：脚本是在子 Shell 中运行的，切换目录不会影响父 Shell 的当前路径。

---

### **方法二：调用时通过子 Shell 切换路径**
在命令行中运行脚本时，通过括号 `()` 创建子 Shell 并切换路径：
```bash
(cd /目标路径 && ./脚本.sh)
```
此时脚本的当前目录为 `/目标路径`，且不影响父 Shell 的路径。

---

### **方法三：使用绝对路径替代相对路径**
在脚本中直接使用绝对路径操作文件，避免依赖当前路径：
```bash
#!/bin/bash
cat /绝对路径/文件.txt   # 不依赖脚本执行时的路径
```

---

### **方法四：自动切换到脚本所在目录**
在脚本中通过 `dirname "$0"` 获取脚本所在目录，并切换过去：
```bash
#!/bin/bash
script_dir=$(dirname "$0")   # 获取脚本所在目录
cd "$script_dir" || exit     # 切换到该目录（若失败则退出）
# 后续操作会在脚本所在目录执行
```
**注意**：如果脚本通过符号链接调用，`$0` 可能指向链接路径，此时可用 `readlink -f` 解析真实路径：
```bash
script_dir=$(dirname "$(readlink -f "$0")")
```

---

### **方法五：临时切换目录（pushd/popd）**
在脚本中临时切换目录，执行完操作后恢复原路径：
```bash
#!/bin/bash
pushd /目标路径 >/dev/null   # 切换目录并压栈（静默输出）
# 在此执行操作...
popd >/dev/null             # 恢复原目录
```

---

### **方法六：调用时指定工作目录**
使用 `bash -c` 或 `sh -c` 直接指定工作目录：
```bash
bash -c "cd /目标路径 && ./脚本.sh"
```

---

### **选择建议**
- 若希望脚本**始终在自己的目录下运行**，推荐**方法四**（结合 `readlink -f` 处理符号链接）。
- 若只是**临时调整路径**，推荐**方法二**或**方法六**（调用时切换）。
- 如果脚本操作的文件位置固定，优先使用**方法三**（绝对路径）。

---

### **注意事项**
1. **权限问题**：确保脚本有权限访问目标目录。
2. **路径存在性**：切换前检查目录是否存在（如 `cd /path || exit`）。
3. **符号链接**：若脚本可能通过符号链接调用，需用 `readlink -f` 解析真实路径。

通过以上方法，可以灵活控制脚本运行时的当前工作路径。



好的！Linux 系统的运行原理是一个庞大的话题，但我们可以从核心概念入手，结合「子 Shell」这一场景，逐步深入到底层机制。以下是精简但系统的解释：

---

### **一、Linux 系统的核心架构**
Linux 系统可以抽象为 **用户空间（User Space）** 和 **内核空间（Kernel Space）** 的两层结构：
1. **用户空间**：
   - 用户程序（如 Shell、文本编辑器、脚本）运行在此层。
   - 所有用户程序**无权直接操作硬件**，必须通过内核提供的接口（系统调用）访问资源。
2. **内核空间**：
   - 内核（Kernel）是操作系统的核心，直接管理 CPU、内存、磁盘、网络等硬件。
   - 提供系统调用（System Calls）供用户程序使用，例如 `fork()`、`exec()`、`open()` 等。
   - 负责进程调度、内存分配、文件系统管理等核心功能。

---

### **二、进程（Process）与 Shell**
#### **1. 什么是进程？**
- 进程是程序的运行实例，每个进程有独立的内存空间、文件描述符、环境变量等。
- Linux 通过 `fork()` 系统调用创建新进程，新进程是原进程的**副本**（称为子进程）。

#### **2. Shell 的本质**
- Shell（如 Bash、Zsh）本身是一个用户空间的进程，负责解释用户输入的命令。
- **当你在终端输入命令时**：
  1. Shell 解析命令（例如 `ls` 或 `./script.sh`）。
  2. Shell 调用 `fork()` 创建一个子进程。
  3. 子进程通过 `exec()` 系统调用加载目标程序（如 `/bin/ls`）并执行。
  4. 父进程（Shell）通过 `wait()` 等待子进程结束。

#### **3. 子 Shell（Subshell）的原理**
- **子 Shell 是 Shell 进程通过 `fork()` 创建的子进程**。
  - 例如：`(cd dir && ./script.sh)` 中的括号会启动一个子 Shell。
  - 子 Shell 继承父 Shell 的环境变量，但**修改环境（如当前目录）不会影响父 Shell**（因为父子进程内存独立）。
- 子 Shell 结束后，资源被回收，控制权交回父 Shell。

---

### **三、系统调用的关键角色**
#### **1. `fork()`：创建进程**
- 内核复制父进程的内存、文件描述符等生成子进程。
- 子进程从 `fork()` 返回处继续执行，通过返回值区分父子进程。

#### **2. `exec()`：替换进程映像**
- 子进程调用 `exec()` 加载新程序（如 `/bin/bash` 或自定义脚本），覆盖原有内存。
- 例如：运行 `./script.sh` 时，子进程的代码被脚本内容替换。

#### **3. `wait()`：回收子进程**
- 父进程通过 `wait()` 等待子进程结束，避免僵尸进程（Zombie Process）。

---

### **四、文件系统与权限**
#### **1. 一切皆文件**
- Linux 将硬件、设备、管道、目录等抽象为文件，通过统一的文件接口（如 `open()`、`read()`、`write()`）操作。
- **文件描述符（File Descriptor）** 是进程访问文件的句柄（如 `0`=标准输入，`1`=标准输出）。

#### **2. 权限模型**
- 每个文件有**所有者（Owner）、所属组（Group）、其他用户（Others）** 的读写执行权限。
- 进程运行时，其权限取决于启动该进程的用户（通过 UID/GID 控制）。

---

### **五、子 Shell 的底层行为**
#### **1. 子 Shell 的创建过程**
```bash
# 示例：在 Shell 中执行命令
$ (cd /tmp && echo "Hello")  # 启动子 Shell
```
1. 父 Shell 调用 `fork()` 创建子进程。
2. 子进程执行 `cd /tmp`（改变自己的当前目录）。
3. 子进程执行 `echo` 命令（输出到标准输出）。
4. 子进程退出，父 Shell 的当前目录**不受影响**。

#### **2. 环境隔离性**
- 子进程继承父进程的环境变量，但修改仅在子进程内有效（内存隔离）。
- **例外**：若通过 `export` 设置环境变量或使用 `source script.sh`（不创建子 Shell），变量会影响父 Shell。

---

### **六、扩展：进程间通信（IPC）**
- **管道（Pipe）**：`|` 符号的本质是父进程创建管道，子进程的输入输出通过管道连接。
  ```bash
  ls | grep .txt  # 父 Shell 创建两个子进程，通过管道传递数据
  ```
- **信号（Signal）**：通过 `kill` 命令发送信号（如 `SIGTERM`）终止进程。
- **共享内存/Socket**：更高级的进程间通信方式。

---

### **七、理解系统资源的限制**
- **ulimit**：Shell 内置命令，限制单个进程的资源（如打开文件数、内存）。
- **cgroups**：Linux 内核功能，限制进程组的资源（容器技术的核心）。

---

### **总结：Linux 的核心哲学**
1. **一切皆文件**：统一接口简化操作。
2. **进程独立性**：通过 `fork()`/`exec()` 机制实现进程隔离。
3. **最小权限原则**：用户和进程仅拥有必要的权限。

如果想进一步深入，可以研究：
- **系统调用**（使用 `strace` 跟踪命令的系统调用）。
- **内核模块**（动态加载到内核的代码）。
- **Proc 文件系统**（`/proc` 目录下实时查看进程和内核信息）。

理解这些原理后，你会发现 Shell 脚本中的每一个操作（管道、重定向、后台任务）背后都是进程和系统调用的舞蹈。