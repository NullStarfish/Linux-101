GCC 的选项（Options）非常多，但日常开发中真正高频使用的也就 20% 左右。结合你之前关于 Object file 和 Linker 的提问，我把这些选项按照**编译阶段**和**功能用途**进行了分类汇总。

---

### 1. 控制输出产物 (核心流程)
这几个选项决定了编译“停”在哪个阶段（预处理、编译、汇编、链接）。

| 选项              | 作用                        | 产物示例               | 说明                       |
| :-------------- | :------------------------ | :----------------- | :----------------------- |
| **`-c`**        | **Compile only**。只编译不链接。  | `.o` (Object File) | **最常用**。用于生成目标文件，跳过链接步骤。 |
| **`-o <name>`** | **Output**。指定输出文件名。       | 任意 (如 `app`)       | 默认为 `a.out`。             |
| `-S`            | 生成汇编代码。                   | `.s` (Assembly)    | 查看 C 对应的汇编指令时用。          |
| `-E`            | 只进行预处理 (Preprocess)。      | 文本输出               | 宏展开、头文件展开。用于排查宏定义问题。     |
| `-shared`       | 生成动态链接库 (Shared Library)。 | `.so`              | 结合 `-fPIC` 使用。           |

**示例**：
```bash
# 只编译生成 .o (常用于 Makefile)
gcc -c main.c -o main.o 

# 一步到位生成可执行文件
gcc main.c -o my_program
```

---

### 2. 头文件与库文件 (Search Paths)
当你的代码引用了外部库（非标准库）时，必须告诉 GCC 去哪里找。

| 选项 | 参数含义 | 作用 |
| :--- | :--- | :--- |
| **`-I<dir>`** | Include path | 添加**头文件** (`.h`) 的搜索路径。告诉编译器去哪里找 `#include "foo.h"`。 |
| **`-L<dir>`** | Library path | 添加**库文件** (`.a` / `.so`) 的搜索路径。告诉链接器去哪里找库。 |
| **`-l<name>`** | Library name | **链接具体的库**。注意规则：`libm.a` -> `-lm` (去掉 `lib` 和后缀)。 |

**⚠️ 关键坑点：**
`-l` 选项必须写在**依赖它的源文件/目标文件之后**！
*   ❌ 错：`gcc -lm main.c`
*   ✅ 对：`gcc main.c -lm` (因为 linker 是按顺序扫描的，先看到 main 用到了 math，再去库里找)。

---

### 3. 调试与警告 (开发必备)
在开发阶段，这两个选项建议**永远带上**。

| 选项          | 作用                         | 说明                                                 |
| :---------- | :------------------------- | :------------------------------------------------- |
| **`-g`**    | **Debug info**。生成调试信息。     | 加上它，ELF 文件中会包含 `.debug_*` 段和详细的符号表，`gdb` 才能看到源码行号。 |
| **`-Wall`** | **Warning All**。开启大部分常用警告。 | 强烈建议开启，能发现未初始化变量等潜在 Bug。                           |
| `-Wextra`   | 额外的警告。                     | 比 `-Wall` 更严格。                                     |
| `-Werror`   | 把所有警告当成错误。                 | 只要有警告就编译失败，强迫症（和高质量项目）专用。                          |

---

### 4. 优化选项 (发布必备)
控制编译器如何优化机器码。

| 选项 | 级别 | 适用场景 | 备注 |
| :--- | :--- | :--- | :--- |
| `-O0` | 无优化 | 默认。调试最方便，编译最快。 | 变量不会被优化掉，行号对应最准确。 |
| **`-O2`** | 常用优化 | **生产环境标准推荐**。 | 在体积和性能间取得平衡。 |
| `-O3` | 激进优化 | 科学计算、密集运算。 | 可能会增加体积，甚至（极少数情况）导致逻辑错误。 |
| `-Os` | 体积优化 | 嵌入式系统。 | 尽可能减小可执行文件大小。 |

---

### 5. 宏定义与标准 (代码控制)

| 选项 | 作用 | 等价代码 |
| :--- | :--- | :--- |
| **`-D<MACRO>`** | 定义宏。 | `#define MACRO 1` |
| **`-D<NAME>=<VAL>`**| 定义带值的宏。 | `#define NAME VAL` |
| `-std=c99` | 指定 C 语言标准 (c99, c11, gnu11)。 | 默认根据 gcc 版本不同而不同。 |

**场景**：
```bash
# 在代码中可以通过 #ifdef DEBUG 来控制打印日志
gcc -DDEBUG main.c 
```

---

### 6. 链接器相关 (Linker Specific)
这些选项主要用于处理你之前问到的 `.so` 和符号表问题。

| 选项            | 作用                                    | 关联知识点                                   |
| :------------ | :------------------------------------ | :-------------------------------------- |
| **`-fPIC`**   | 产生位置无关代码 (Position Independent Code)。 | 编译 `.so` (动态库) 时**必须**加这个，否则无法在内存中动态加载。 |
| **`-static`** | 强制静态链接。                               | 即使有 `.so`，也强制去链接 `.a`。生成的文件巨大，但不依赖系统库。  |
| `-s`          | Strip。剔除所有符号表和重定位信息。                  | 生成极小的可执行文件（无法调试）。相当于运行了 `strip` 命令。     |
| `-Wl,<opt>`   | 将参数 `<opt>` 传给链接器 `ld`。               | 比如 `-Wl,-rpath=.` 可以指定运行时去当前目录找 `.so`。  |

---

### ⚡️ 黄金组合总结

#### 1. 开发调试阶段 (Debug)
```bash
# 生成 .o，开启调试信息，开启所有警告，定义 DEBUG 宏
gcc -c -g -Wall -DDEBUG main.c -o main.o
```

#### 2. 生成动态库 (Shared Lib)
```bash
# 注意 -fPIC 和 -shared
gcc -fPIC -shared mylib.c -o libmylib.so
```

#### 3. 发布/构建阶段 (Release)
```bash
# 开启 O2 优化，引用 pthread 库，头文件在 ./include，库在 ./lib
gcc -O2 -I./include -L./lib main.c -o app -lpthread
```