GDB (GNU Debugger) 的命令非常多，但就像 GCC 选项一样，真正每天高频使用的只有 10-15 个。

为了方便记忆，我把它们按**使用场景**分了类。在开始之前，请确保编译时加了 **`-g`** 选项（`gcc -g main.c -o app`），否则 GDB 看不到函数名和行号。

---

### 1. 启动与退出 (Start & Stop)

| 命令 | 简写 | 作用 | 示例 |
| :--- | :--- | :--- | :--- |
| `gdb <file>` | | 启动 GDB 并加载程序 | `gdb ./a.out` |
| `run` | **`r`** | **开始运行程序**。如果有参数，跟在后面。 | `r` 或 `r arg1 arg2` |
| `start` | | 开始运行并在 `main` 函数的第一行自动暂停。 | `start` |
| `quit` | **`q`** | 退出 GDB。 | `q` |
| `kill` | `k` | 杀死当前正在调试的程序（但不退出 GDB）。 | `k` |

---

### 2. 断点管理 (Breakpoints)
这是最基础的操作，告诉程序在哪里停下来。

| 命令 | 简写 | 作用 | 示例 |
| :--- | :--- | :--- | :--- |
| `break <loc>` | **`b`** | 设置断点。可以是**函数名**、**行号**或**文件名:行号**。 | `b main` <br> `b 25` <br> `b test.c:10` |
| `info break` | **`i b`** | 查看当前所有断点及其编号 (Num)。 | `i b` |
| `delete <Num>`| **`d`** | 删除指定编号的断点。如果不填编号，删除所有。 | `d 1` (删1号) <br> `d` (删所有) |
| `enable/disable` | | 启用/禁用断点（不删除，只是暂时失效）。 | `disable 1` |
| **`watch <expr>`**| | **数据断点**（神器）。当变量值**发生改变**时暂停。 | `watch counter` |

> **高级技巧 - 条件断点**：
> `b test.c:15 if i == 100` （只有当 i 等于 100 时才在第 15 行停下来，循环调试必备）。

---

### 3. 执行控制 (Execution)
程序停下来后，你需要控制它一步步往下走。

| 命令 | 简写 | 作用 | 区别 |
| :--- | :--- | :--- | :--- |
| `next` | **`n`** | **单步跳过** (Step Over)。 | 遇到函数调用时，**不进入**函数内部，直接执行完该函数。 |
| `step` | **`s`** | **单步进入** (Step Into)。 | 遇到函数调用时，**跳入**函数内部逐行调试。 |
| `continue` | **`c`** | **继续运行**。 | 直到遇到下一个断点或程序结束。 |
| `finish` | | **执行完当前函数**并返回。 | 当你不小心 `s` 进了一个冗长的函数，想赶紧跳出来时用。 |
| `until` | `u` | 运行直到指定行号。 | 用于快速跳出循环：`u 20`。 |

---

### 4. 查看数据 (Inspection)
查看变量的值、内存的内容。

| 命令               | 简写      | 作用                                | 示例                                                |
| :--------------- | :------ | :-------------------------------- | :------------------------------------------------ |
| `print <expr>`   | **`p`** | 打印变量或表达式的值。                       | `p count` <br> `p *ptr` (解引用) <br> `p head->next` |
| `ptype`          |         | 查看变量的类型定义。                        | `ptype struct_var`                                |
| `display <expr>` |         | **自动显示**。每走一步都自动打印这个变量。           | `display i`                                       |
| `info locals`    |         | 打印当前栈帧所有局部变量。                     |                                                   |
| `info registers` | `i r`   | 查看 CPU 寄存器 (rax, rbx, rip...) 的值。 |                                                   |

#### ⭐️ 内存查看神器：`x` (Examine)
这是底层调试最核心的命令，格式：**`x /<n><f><u> <addr>`**
*   `n`: 个数
*   `f`: 格式 ( **x**:十六进制, **d**:十进制, **s**:字符串, **i**:汇编指令)
*   `u`: 单位 ( **b**:byte, **h**:halfword-2bytes, **w**:word-4bytes, **g**:giant-8bytes)

**示例**：
*   `x/10xw &buffer`：以 16 进制、4 字节为单位，查看 buffer 地址开始的 10 个单位。
*   `x/s str_ptr`：查看指针指向的字符串。
*   `x/5i $pc`：查看当前程序计数器 (PC) 后面的 5 条**汇编指令**。

---

### 5. 堆栈与上下文 (Stack & Context)
程序崩了 (Segfault)，通常你需要知道“我是从哪调过来的”。

| 命令          | 简写       | 作用                         | 示例                              |
| :---------- | :------- | :------------------------- | :------------------------------ |
| `backtrace` | **`bt`** | **查看函数调用栈**。最常用的崩溃分析命令。    | `bt`                            |
| `frame <N>` | **`f`**  | 切换到第 N 层栈帧。切换后可以查看那层的局部变量。 | `f 2`                           |
| `list`      | **`l`**  | 查看源代码。                     | `l` (往下看) <br> `l 10` (看第10行附近) |

---

### 6. 黑科技：修改运行时数据
你可以在调试过程中直接改变量的值，验证逻辑，而不需要重新编译。

*   `set var i = 50`：把变量 `i` 的值强行改成 50。
*   `set {int}0x400120 = 10`：把内存地址处的值强行改成 10。

---

### 7. 视觉增强：TUI 模式 (Text User Interface)
GDB 自带一个简单的图形界面，能同时看代码和命令，不用一直敲 `list`。

*   **`layout src`**：显示源代码窗口。
*   **`layout asm`**：显示汇编代码窗口。
*   **`layout split`**：**双屏模式**（上面汇编，中间源码，下面命令）。强烈推荐！
*   **`Ctrl + X`, `A`**：退出/进入 TUI 模式（有时候花屏了可以按这个重置）。

---

### 总结：一套“组合拳”
当你遇到 `Segmentation fault` 时，标准的肌肉记忆操作是：

1.  `gdb ./app` （启动）
2.  `r` （运行，直到崩溃，GDB 会告诉你停在哪里）
3.  `bt` （查看死在哪个函数，谁调用的）
4.  `f N` （切到你写的代码的那一层栈帧）
5.  `p var` （查看那个时刻变量是不是 NULL 或者非法值）