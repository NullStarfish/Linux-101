一个 Object File（目标文件，通常是 `.o` 文件）是编译器把你的源码（`.c`）翻译成机器码后的产物，但它还只是一个**“半成品”**。

如果把最终的可执行文件比作一个**完整的拼图**，那么 Object File 就是其中一块**带有锯齿接口的拼图碎片**。它包含了代码和数据，但边缘（外部引用）还没有和别的碎片扣在一起。

具体来说，一个标准的 ELF 格式 Object File 包含以下几个核心部分：

---

### 1. ELF Header（文件头）
这是文件的身份证。对于 Object File，最关键的信息是：
*   **Type**: `REL` (Relocatable file)。这明确告诉系统：“我是一个可重定位文件，我不能直接运行，请先把我链接起来。”
*   **Entry Point**: `0x0`。因为它不是程序入口，没有启动地址。

### 2. 代码与数据段（正文内容）
这是你写的 C 代码转换成的“干货”，但它们的状态比较特殊：

*   **`.text` (代码段)**: 存放编译后的机器指令。
    *   **关键特征**：所有的地址都是从 `0x0000` 开始计算的相对偏移。
    *   **关键特征**：凡是调用外部函数（如 `printf`）或者访问全局变量的地方，指令里的地址暂时填的都是“占位符”（通常是 0）。
*   **`.data`**: 存放已初始化的全局变量（如 `int g_var = 10;`）。
*   **`.rodata`**: 存放只读数据（如 `const` 变量、字符串常量 `"hello\n"`）。
*   **`.bss`**: 定义未初始化的全局变量。它在文件中**不占实际字节**，只记录“需要预留多少空间”。

### 3. 重定位表 (Relocation Table) —— Object File 的灵魂
**这是 Object File 和 Executable File 最大的区别所在。**

因为编译器在编译 `a.c` 时，不知道 `printf` 在哪里，也不知道 `b.c` 里的变量在哪里，所以它生成了重定位表，专门给链接器留“便条”。

通常有两个主要的重定位表：
*   **`.rel.text` (代码重定位表)**：记录了 `.text` 段中哪些指令需要修改。
    *   *内容示例*：“在 `.text` 偏移 `0x20` 的地方，有一条 `call` 指令，它现在的操作数是 0。请链接器找到符号 `printf` 的真实地址后，把这个 0 替换掉。”
*   **`.rel.data` (数据重定位表)**：记录了 `.data` 段中哪些数据指针需要修改。
    *   *示例*：如果你写了 `int *p = &g_val;`，而 `g_val` 是外部定义的，这里就会有一条记录。

### 4. 符号表 (Symbol Table, `.symtab`)
这是 Object File 对外沟通的接口。它列出了这个文件“能提供什么”和“需要什么”。符号表里的条目主要分三类：

1.  **Defined Global Symbols (导出符号)**:
    *   **含义**：“我定义了 `main` 函数，地址在偏移 `0x00`；我定义了变量 `count`，地址在偏移 `0x04`。”
    *   **作用**：供其他 `.o` 文件引用。
2.  **Undefined Symbols (未定义符号)**:
    *   **含义**：“我用到了一个叫 `printf` 的函数，但我不知道它在哪里。”
    *   **作用**：这是个欠条，链接器看到这个后，会去其他 `.o` 或库文件里找谁定义了 `printf`。
3.  **Local Symbols (局部符号)**:
    *   **含义**：`static int private_var;` 或 `static void helper();`。
    *   **作用**：仅在本文件内部可见，链接器在处理全局符号冲突时会忽略它们。

### 5. Section Header Table (节头表)
这是一个目录，记录了上面所有段（`.text`, `.data`, `.rel.text`, `.symtab` 等）在文件中的偏移量、大小和属性。链接器通过它来解析文件结构。

---

### 一个具体的例子

假设你有 `test.c`:
```c
extern int ext_var;      // 外部变量
void func(void);         // 外部函数

int my_global = 42;      // 1. 定义导出符号

void main() {
    func();              // 2. 引用未定义符号
    ext_var = my_global; // 3. 引用外部变量 + 内部变量
}
```

编译生成的 `test.o` 内部结构如下：

1.  **`.text`**:
    *   包含 `main` 的机器码。
    *   在调用 `func` 的地方，机器码是 `call 0x00000000`。
    *   在访问 `ext_var` 的地方，地址也是 `0x00000000`。
2.  **`.data`**:
    *   包含整数 `42`（即 `my_global` 的值）。
3.  **`.symtab` (符号表)**:
    *   `my_global`: **Global, Defined** (在 .data 段偏移 0 处)。
    *   `main`: **Global, Defined** (在 .text 段偏移 0 处)。
    *   `func`: **Global, Undefined** (不知道在哪)。
    *   `ext_var`: **Global, Undefined** (不知道在哪)。
4.  **`.rel.text` (重定位表)**:
    *   条目1: 这里的 `call` 指令指向 `func`，请链接时填入正确地址。
    *   条目2: 这里的 `mov` 指令指向 `ext_var`，请链接时填入正确地址。

### 总结
一个 Object File 实际上就是一个**“待办事项清单”**：
*   **我做好了什么**：代码段、数据段、导出符号。
*   **我缺什么**：未定义符号。
*   **哪里需要修补**：重定位表。

链接器的工作就是收集所有的清单，把“做好的”和“缺的”配对，根据“修补指南”把地址填好，最后合并成一个可执行文件。