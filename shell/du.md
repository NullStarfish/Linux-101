这张 PPT 介绍了 Linux 中另一个极其实用的磁盘管理工具：**`du` (Disk Usage)**。

如果说 `df` 是看“这块地总共有多大，还剩多少”，那么 `du` 就是看“**这块地里的每个房间（文件夹/文件）分别住了多少人**”。

---


-s:sum, -k:kilobytes, -h:humanreadable, -m:MB




`du` (Disk Usage) 是 Linux 系统中用于查看**文件或目录占用磁盘空间大小**的常用命令。

以下是 `du` 命令的常用选项汇总及其典型用法。

---

### 一、 核心选项汇总

| 选项                    | 长选项                 | 说明                              |
| :-------------------- | :------------------ | :------------------------------ |
| **`-h`**              | `--human-readable`  | 以易读格式显示（如 1K, 234M, 2G）。        |
| **`-s`**              | `--summarize`       | 仅显示总计，不列出子目录的明细。                |
| **`-a`**              | `--all`             | 列出目录和**所有文件**的大小（默认只显示目录）。      |
| **`-c`**              | `--total`           | 在最后一行显示所有列出项的**总和**。            |
| **`-d N`**            | `--max-depth=N`     | 递归显示的深度。`-d 1` 表示只看当前目录下的一级子目录。 |
| **`-k`**              |                     | 以 KB 为单位显示（默认单位）。               |
| **`-m`**              |                     | 以 MB 为单位显示。                     |
| **`-x`**              | `--one-file-system` | 跳过不同文件系统的目录（例如挂载的外部硬盘或虚拟文件系统）。  |
| **`-S`**              | `--separate-dirs`   | 显示目录本身大小，不包含其子目录的大小。            |
| **`--time`**          |                     | 显示目录或文件的最后修改时间。                 |
| **`--exclude="PAT"`** |                     | 排除符合匹配规则的文件或目录。                 |

---

### 二、 常见用法示例

#### 1. 查看当前目录的总大小
这是最常用的命令，`-s` 表示汇总，`-h` 表示易读。
```bash
du -sh
```

#### 2. 查看当前目录下每个子目录的大小（深度为1）
如果你想知道哪个文件夹占用了空间，这个命令最有效：
```bash
du -h --max-depth=1
# 或者简写 (在某些版本的 du 中)
du -hd 1
```

#### 3. 查看当前目录下所有文件和目录的大小
默认 `du` 只看目录，加 `-a` 可以看到具体文件：
```bash
du -ah
```

#### 4. 显示所有项目的总和
如果你选中了多个目录，想看它们的总和：
```bash
du -ch dir1 dir2
```
*最后一行会多出一个 `total` 行。*

#### 5. 按照空间大小排序（进阶组合）
找出当前目录下最大的 10 个文件或文件夹：
```bash
du -ah --max-depth=1 | sort -rh | head -n 10
```
*解释：`sort -r` 是逆序，`-h` 是识别人类可读格式（如 1G > 10M）。*

#### 6. 排除特定目录
例如查看当前目录，但排除 `node_modules` 文件夹：
```bash
du -h --exclude="node_modules"
```

---

### 三、 重要提示：du vs df

很多新手会混淆 `du` 和 `df`：

*   **`du` (Disk Usage):** 针对**文件和目录**。它通过遍历文件系统来计算空间。速度较慢，但能定位具体哪个文件夹大。
*   **`df` (Disk Free):** 针对**文件系统（分区）**。它直接从文件系统元数据读取空间使用情况。速度极快，用于查看整个磁盘还剩多少空间。

**常见问题：为什么 `du` 和 `df` 结果不一致？**
如果一个大文件被删除了，但仍有进程在占用它（未释放句柄），`df` 会显示空间未释放，而 `du` 无法统计到这个“已删除”的文件，导致两者结果不同。此时通常需要重启相关服务或杀死进程。




### 1. PPT 内容解读

*   **`du /home`**：
    *   **行为**：递归（Recursively）地报告 `/home` 目录下每一个子目录和文件的大小。
    *   **默认表现**：如果不加任何参数，`du` 通常会列出所有文件夹的大小。
*   **`du -ks file`**：
    *   **`-k`**：以 **Kilobytes (KB)** 为单位显示。
    *   **`-s` (Summary)**：**只显示总计**。这是最常用的参数之一。
    *   **行为**：它不会列出文件内部的细节，只给你一个最终的加总数字。

---

### 2. `du` vs `df`：本质区别（重要！）

这是 Linux 面试或考试中最常考的点，结合我们之前讲的 **Inode** 和 **Superblock**：

| 特性 | `df` (Disk Free) | `du` (Disk Usage) |
| :--- | :--- | :--- |
| **数据来源** | 读取文件系统的 **Superblock** | 遍历 **Inode 树**，累加每个文件的大小 |
| **速度** | 极快（瞬间完成） | 较慢（文件越多，扫描越久） |
| **关注点** | 整个分区的剩余空间 | 具体目录或文件占用的空间 |
| **应用场景** | 确认硬盘坏没坏、满没满 | 找出到底是哪个文件夹把硬盘占满了 |

---

### 3. `du` 的实用高级用法（PPT 之外）

在实际工作中，PPT 里的 `-ks` 已经不够用了，你最常用的应该是下面这些组合：

#### A. 寻找“空间杀手”：`du -h --max-depth=1`
当你发现磁盘满了，你想知道 `/var` 目录下哪个子文件夹最大，但又不想看几千行递归输出：
```bash
sudo du -h --max-depth=1 /var
```
*   **`-h`**：人类可读（显示 G, M, K）。
*   **`--max-depth=1`**：只看当前层级，不递归到更深的子文件夹。

#### B. 包含文件在内的列表：`du -ah`
默认 `du` 只列出目录大小。如果你想看目录下**每一个文件**的大小：
```bash
du -ah ./my_project
```
*   **`-a` (all)**：列出目录+文件。

#### C. 自动排序：找出最大的前 10 个文件夹
这是一个经典的运维组合命令：
```bash
sudo du -hm /var | sort -nr | head -n 10
```
*   **`-m`**：以 MB 为单位（方便排序）。
*   **`sort -nr`**：按数字（-n）逆序（-r，从大到小）排序。
*   **`head -n 10`**：只看前十名。

---

### 4. 硬核细节：`du` 计算的是“磁盘占用”而非“逻辑大小”

这是很多 C 程序员会感到困惑的地方：

1.  **稀疏文件 (Sparse Files)**：
    如果你用 `dd` 创建了一个 1GB 的文件但里面全是空洞（不实际占磁盘块），`ls -l` 会显示 1GB，但 `du` 可能会告诉你它只占了 0 KB。
2.  **块开销**：
    如果你存了 100 万个只有 1 字节的文件，`ls` 会告诉你总大小是 1MB。但由于每个文件至少占一个磁盘块（通常 4KB），`du` 会告诉你占用了接近 4GB！

### 总结
*   想看 **硬盘** 还有多少空间，用 **`df -h`**。
*   想看 **哪个文件夹** 占了空间，用 **`du -sh *`**。
*   **`du`** 是通过一个一个去查 **Inode** 指向了多少个 **Data Blocks** 来累加计算的。




这是一个非常关键的误解，很多初学者都会在这里产生困惑。答案是：**不，完全不是。**

让我们把这两个概念彻底理清楚：

### 1. 文件夹（目录）的大小到底是什么？

在 Linux 中，“文件夹”本质上也是一个**特殊的文件**，它的内容是一张表，记录了：**文件名 <--> Inode 编号** 的映射关系。

*   **当你用 `ls -ld` 看到的大小时（比如 4096 字节）：**
    这指的是**存储“文件名列表”这张表**所消耗的磁盘块大小。
    *   如果文件夹里只有几个文件，这张表很小，占一个块（4KB）。
    *   如果文件夹里有几万个文件，文件名列表变长，这个大小会变成 12KB、20KB 等。
    *   **这绝对不包含文件夹里文件的内容大小。**

*   **当你用 `du` 看到文件夹大小时：**
    `du` 的目的是告诉你“**这个文件夹一共占用了多少磁盘空间**”。
    因此，它展现的大小是：
    **文件夹自身的大小 + 下面所有文件的大小 + 所有子目录的大小（递归计算）**。

---

### 2. `-s` 参数的作用：是“总和”吗？

**是的。** `-s` (Summary) 的作用就是把递归计算的所有结果**合并成一个总数**显示出来。

#### 举个例子对比一下：

假设你有一个目录结构如下：
```text
/my_data (文件夹自身 4KB)
    ├── file1.txt (10KB)
    ├── file2.txt (20KB)
    └── /sub_dir (文件夹自身 4KB)
           └── file3.txt (30KB)
```

1.  **执行 `du /my_data`（不带 -s）：**
    它会按顺序打印每一层：
    *   `34KB  /my_data/sub_dir` (30KB文件 + 4KB文件夹本身)
    *   `68KB  /my_data` (30+4 + 10 + 20 + 4)
    *（它会把递归过程中的每一个目录节点的大小都打印出来）*

2.  **执行 `du -s /my_data`：**
    它会**只输出最后一行**：
    *   `68KB  /my_data`
    *（它在后台默默算完了所有加法，只给你看最后的总账）*

---

### 3. 为什么不包含 Inode 大小？

这是一个非常深入的细节：

*   **Inode 区域是预留的**：在 ext4 文件系统格式化时，Inode Table 的空间就已经在磁盘上固定分配好了。
*   **`du` 统计的是“数据块占用”**：`du` 计算的是文件实际占用了磁盘上的哪些 **Data Blocks**。
*   **Inode 即使没被用，空间也在那**：所以 `du` 通常不计入 Inode 结构体本身占用的那一点点空间（每个 Inode 通常只有 128 或 256 字节），它计入的是 Inode 指向的数据块（Data Blocks）。

### 总结：

*   **`du` 看到的文件夹大小** = **该路径下所有内容的物理磁盘占用总和**。
*   **`-s`** = **只看总结果**，屏蔽中间子目录的明细。
*   如果你只想看“文件夹这个表文件”本身多大，请用 `ls -ld`。

**一个小实验：**
你可以创建一个空文件夹，用 `du -sh` 看是 4KB（文件夹自身开销），然后往里放一个 1GB 的文件，再用 `du -sh` 看，就变成 1GB 了。这证明了 `du` 算的是**包含关系**。


这是一个非常经典的误区，我们需要把**“Inode 结构体的大小”**和**“ls -l 显示的大小”**这两个概念完全剥离开。

简单直接的回答是：**`ls -l` 中文件夹的大小，既不是 Inode 的大小，也不是文件夹里所有文件的总和，而是“存放这个文件夹下文件名列表”的那个特殊文件的大小。**

以下是详细的硬核拆解：

---

### 1. Inode 到底多大？
在 ext4 文件系统格式化时，Inode 的大小是**固定**的。
*   通常每个 Inode 是 **256 字节**（也有老系统是 128 字节）。
*   无论这个 Inode 对应的是 1KB 的小文件，还是 1TB 的大文件，甚至是 1 个字节都没有的空文件夹，这个 **Inode 结构体本身永远是 256 字节**。
*   这个 256 字节存放在磁盘专门的“Inode Table”区域，**`ls -l` 从来不会显示这个数字。**

---

### 2. `ls -l` 看到的文件夹大小是什么？
在 Linux 中，“一切皆文件”，**文件夹也是一个文件**。
*   **普通文件**的内容是：数据（比如文字、代码、图片）。
*   **文件夹文件**的内容是：一张**列表**（记录了：这个目录下有哪些文件名，以及它们对应的 Inode 号）。

当你运行 `ls -l` 时，看到的那个数字（通常是 **4096**）：
*   它是这个“文件名列表”文件**占用的磁盘块大小**。
*   **为什么经常是 4096？** 因为 ext4 的一个块（Block）通常是 4096 字节（4KB）。即使文件夹里只有 1 个文件，系统也要分配至少一个完整的块来存这张表。
*   **它什么时候会变？** 如果你在这个文件夹下创建了几千个文件，这张表变长了，4KB 放不下了，系统就会分配更多的块（比如变成 12288，即 12KB）。

---

### 3. 三个概念的终极对比

假设我们看一个叫 `my_dir` 的文件夹：

| 概念 | 代表什么 | 大小示例 |
| :--- | :--- | :--- |
| **Inode 自身大小** | 存权限、时间戳、指针的结构体。 | **256 字节** (固定，不可见) |
| **`ls -l my_dir`** | 存放“文件名列表”这张表的大小。 | **4096 字节** (通常是 4K 的倍数) |
| **`du -sh my_dir`** | 文件夹 + 里面所有文件的总占用。 | **1.5 GB** (逻辑上的内容总和) |

---

### 4. 形象的类比

想象你在图书馆管理一排书架（文件夹）：

1.  **Inode**：是一张**借书卡**。上面记着书架位置、管理员是谁。这张卡片的大小是固定的（比如 3x5 英寸）。
2.  **`ls -l` 的大小**：是贴在书架侧面的那张**目录清单（纸）**的大小。如果书架上书少，一张纸就够了；如果书多，可能要贴好几张纸。4096 就是这张“纸”的大小。
3.  **`du` 的大小**：是这个书架上**所有书本的总重量**。

### 总结
你看到的 `ls -l` 中的 `4096`，是**目录文件（Directory File）的逻辑长度**。它指向的是磁盘上的数据块，里面存着该目录下所有文件的“姓名”和“学号（Inode ID）”。

它**绝对不是** Inode 结构体本身的大小。如果你想看 Inode 的详细信息，可以执行：
```bash
stat 文件夹名
```
你会发现 `Size`（ls 看到的大小）和 `IO Block`、`Inode` 编号是分开展示的。如果你看 `Inode` 的详细底层参数（通过 `dumpe2fs`），你才会看到那个固定的 256 字节。