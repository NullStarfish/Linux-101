# Shell 字符串操作（参数扩展）详解

Shell 提供了一套强大的字符串操作语法，这些操作都是通过**参数扩展** `${ }` 实现的。让我们详细学习：

## **基本语法格式**

```bash
${parameter#word}      # 从前删除最短匹配
${parameter##word}     # 从前删除最长匹配  
${parameter%word}      # 从后删除最短匹配
${parameter%%word}     # 从后删除最长匹配
${parameter/pattern/string}  # 替换第一个匹配
${parameter//pattern/string} # 替换所有匹配
```

## **1. 删除操作（掐头去尾）**

### **从开头删除（掐头）**
```bash
# 删除最短匹配的前缀（非贪婪）
file="backup.tar.gz"
echo ${file#*.}        # tar.gz
# 找到第一个 . 删除前面的 backup

# 删除最长匹配的前缀（贪婪）
echo ${file##*.}       # gz
# 找到最后一个 . 删除前面的 backup.tar
```

### **从结尾删除（去尾）**
```bash
# 删除最短匹配的后缀（非贪婪）
file="backup.tar.gz"
echo ${file%.*}        # backup.tar
# 找到最后一个 . 删除后面的 gz

# 删除最长匹配的后缀（贪婪）
echo ${file%%.*}       # backup
# 找到第一个 . 删除后面的 tar.gz
```

## **2. 替换操作**

### **替换第一个匹配**
```bash
path="/home/user/file.txt"
echo ${path/file/doc}      # /home/user/doc.txt
# 只替换第一个 file

# 可以用模式
echo ${path/*\//}          # user/file.txt
# 删除第一个 / 及其之前的内容
```

### **替换所有匹配**
```bash
text="hello world hello everyone"
echo ${text//hello/hi}     # hi world hi everyone

# 删除所有空格
text="a b c d"
echo ${text// /}           # abcd

# 替换所有点
file="a.b.c.d.txt"
echo ${file//./-}          # a-b-c-d-txt
```

### **指定位置替换**
```bash
# 从开头替换
text="abcabcabc"
echo ${text/#abc/XYZ}      # XYZabcabc

# 从结尾替换  
echo ${text/%abc/XYZ}      # abcabcXYZ

# 中间不替换
echo ${text/abc/XYZ}       # XYZabcabc（只替换第一个）
```

## **3. 子字符串提取**

```bash
# ${var:offset:length}
string="hello world"

echo ${string:0}       # hello world（从0开始到结尾）
echo ${string:1}       # ello world（从1开始）
echo ${string:6}       # world（从6开始）

echo ${string:0:5}     # hello（从0开始取5个字符）
echo ${string:6:3}     # wor（从6开始取3个字符）

# 负数偏移（从结尾算起）
echo ${string: -5}     # world（注意-5前有空格）
echo ${string: -5:3}   # wor

# 实际应用
url="https://www.example.com/path/to/file"
echo ${url:8}          # www.example.com/path/to/file
echo ${url#*//}        # 同上（不同方法）
```

## **4. 大小写转换**

```bash
text="Hello World"

# 转大写
echo ${text^^}         # HELLO WORLD
echo ${text^}          # Hello World（首字母大写）

# 转小写
text2="HELLO WORLD"
echo ${text2,,}        # hello world
echo ${text2,}         # hELLO WORLD（首字母小写）

# 选择性转换
echo ${text^^[hw]}     # Hello World（只转h和w）
echo ${text,,[HW]}     # hello world（只转H和W）

# 变量转大写
var="myVariable"
uppercase=${var^^}
echo $uppercase        # MYVARIABLE
```

## **5. 默认值处理**

```bash
# ${var:-default} - 如果空或未设置，使用默认值（不改变var）
unset var
echo ${var:-guest}     # guest
echo $var              # 空（var未改变）

# ${var:=default} - 如果空或未设置，设置var为默认值
unset var
echo ${var:=guest}     # guest
echo $var              # guest（var已被设置）

# ${var:?error_msg} - 如果空或未设置，显示错误并退出
unset var
echo ${var:?"var is required"}  # 报错退出

# ${var:+alternate} - 如果设置了，使用alternate
var="original"
echo ${var:+replaced}  # replaced
unset var
echo ${var:+replaced}  # 空
```

## **6. 字符串长度**

```bash
string="hello"
echo ${#string}        # 5

# 数组长度
arr=(a b c d e)
echo ${#arr[@]}        # 5（元素个数）
echo ${#arr[*]}        # 5（同上）

# 数组元素长度
arr=("hello" "world")
echo ${#arr[0]}        # 5（第一个元素长度）
echo ${#arr[1]}        # 5（第二个元素长度）
```

## **7. 数组操作**

```bash
# 创建数组
fruits=("apple" "banana" "cherry" "date")

# 所有元素
echo ${fruits[@]}      # apple banana cherry date
echo ${fruits[*]}      # apple banana cherry date

# 切片
echo ${fruits[@]:1}    # banana cherry date（从索引1开始）
echo ${fruits[@]:1:2}  # banana cherry（从1开始取2个）

# 元素长度
echo ${#fruits[0]}     # 5（apple的长度）

# 数组长度
echo ${#fruits[@]}     # 4
```

## **8. 模式匹配扩展**

```bash
# 查找模式匹配
file="backup-2023-12-29.tar.gz"

# 删除前缀模式
echo ${file#backup-}           # 2023-12-29.tar.gz
echo ${file##backup-}          # 同上（只有一个backup-）

# 删除后缀模式  
echo ${file%.tar.gz}           # backup-2023-12-29
echo ${file%%.tar.gz}          # backup-2023-12-29（同上）

# 更复杂的模式
echo ${file/#backup-/}         # 2023-12-29.tar.gz
echo ${file/%-*-*.tar.gz/}     # backup
```

## **9. 实际应用示例**

### **例1：文件处理**
```bash
# 处理文件名
fullname="/home/user/docs/report.txt"

# 提取各部分
filename=${fullname##*/}        # report.txt
dirname=${fullname%/*}          # /home/user/docs
basename=${filename%.*}         # report
extension=${filename##*.}       # txt

echo "文件: $filename"
echo "目录: $dirname" 
echo "名称: $basename"
echo "扩展: $extension"

# 批量修改扩展名
for file in *.txt; do
    mv "$file" "${file%.txt}.md"
done
```

### **例2：路径处理**
```bash
# URL解析
url="https://www.example.com:8080/path/to/resource?param=value"

protocol=${url%%://*}           # https
rest=${url#*://}                # www.example.com:8080/path/to/resource?param=value
hostport=${rest%%/*}            # www.example.com:8080
host=${hostport%:*}             # www.example.com
port=${hostport##*:}            # 8080
path=${rest#*/}                 # path/to/resource?param=value
```

### **例3：日志处理**
```bash
# 清理日志内容
log="ERROR: 2023-12-29 10:30:45 - User not found [ID: 12345]"

# 提取错误类型
err_type=${log%%:*}             # ERROR
# 提取时间戳
timestamp=${log#*: }            # 2023-12-29 10:30:45 - User not found [ID: 12345]
timestamp=${timestamp%% -*}     # 2023-12-29 10:30:45
# 提取消息
message=${log#* - }             # User not found [ID: 12345]
# 提取ID
id=${message#*[ID: }            # 12345]
id=${id%]*}                     # 12345
```

### **例4：配置处理**
```bash
# 解析INI格式
config="database.host=localhost"

# 分离键值
key=${config%=*}                # database.host
value=${config#*=}              # localhost

# 进一步分解key
section=${key%.*}               # database
option=${key##*.}               # host
```

### **例5：字符串验证**
```bash
# 检查是否以特定字符串开头/结尾
filename="backup-20231229.tar.gz"

if [[ ${filename#backup-} != "$filename" ]]; then
    echo "这是一个备份文件"
fi

if [[ ${filename%.tar.gz} != "$filename" ]]; then
    echo "这是一个tar.gz压缩包"
fi

# 检查扩展名
ext=${filename##*.}
case $ext in
    gz|tgz) echo "gzip压缩文件" ;;
    zip) echo "zip压缩文件" ;;
    *) echo "未知类型: $ext" ;;
esac
```

## **10. 高级技巧**

### **嵌套扩展**
```bash
# 多层处理
path="/usr/local/bin/app"
echo ${${path##*/}%.*}          # app（先取最后部分，再去扩展名）

# 但嵌套扩展在某些shell中不支持，可以：
basename=${path##*/}            # app
name=${basename%.*}             # app
```

### **默认值与替换结合**
```bash
# 如果变量为空，使用默认值并进行替换
unset title
echo ${title:-untitled// /_}    # untitled（先替换空格？不，这不行）

# 正确做法：
default="untitled document"
echo ${title:-$default}         # untitled document
echo ${title:-$default// /_}    # untitled_document
```

### **与正则表达式结合**
```bash
# 注意：这不是真正的正则，是shell通配符模式
text="abc123def456"

# 删除所有数字
echo ${text//[0-9]/}            # abcdef

# 删除所有字母
echo ${text//[a-z]/}            # 123456

# 替换特定模式
echo ${text//[0-9]/-}           # abc---def---
```

## **11. 记忆技巧**

| 符号 | 含义 | 记忆方法 |
|------|------|----------|
| `#` | **从前**删除 | `#` 在键盘左边 → 开头 |
| `%` | **从后**删除 | `%` 在键盘右边 → 结尾 |
| 一个符号 | 最短匹配（非贪婪） | 少就是小 → 短 |
| 两个符号 | 最长匹配（贪婪） | 多就是大 → 长 |
| `/` | 替换 | 像路径分隔符，用于替换 |
| 一个`/` | 替换第一个 | 少就是小 → 第一个 |
| 两个`/` | 替换所有 | 多就是大 → 所有 |

**口诀**：
- **`#` 掐头**，**`%` 去尾**
- **一个短**，**两个长**  
- **`/` 替换**，**`//` 全换**

## **12. 与外部命令对比**

```bash
# 提取文件名
file="/path/to/file.txt"

# Shell内置（最快）
name=${file##*/}

# 使用 basename 命令
name=$(basename "$file")

# 使用 awk
name=$(echo "$file" | awk -F/ '{print $NF}')

# 建议：简单操作用Shell内置，复杂用外部命令
```

## **性能建议**
1. **优先使用内置操作**：比调用外部命令快得多
2. **避免过度嵌套**：代码可读性更重要
3. **复杂模式用正则**：如果shell模式不够用，用`grep`、`sed`、`awk`
4. **大文本用外部工具**：Shell内置操作适合中等长度字符串

这些字符串操作是Shell脚本编程的核心技能，掌握后能让你的脚本更简洁高效！