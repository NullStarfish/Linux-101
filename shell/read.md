`read` 是 Linux/Unix 系统中 Bash 及其他主流 Shell（如 Zsh、Sh）的**内置命令**。它的主要功能是从标准输入（键盘）或文件描述符中读取一行文本，并将其内容拆分后赋值给一个或多个变量。

在编写交互式脚本或处理文本文件时，`read` 是最常用的工具之一。

### 1. 基本语法
```bash
read [选项] [变量名...]
```
*   **如果不指定变量名**：读取的内容会自动存入内置变量 `$REPLY` 中。
*   **如果指定一个变量名**：整行内容（去掉行首行尾空白）存入该变量。
*   **如果指定多个变量名**：输入会根据分隔符（通常是空格/制表符）进行拆分，依次赋值给变量；多出的部分会全部存入最后一个变量。

---

### 2. 常用选项（Flags）

| 选项 | 说明 | 示例 |
| :--- | :--- | :--- |
| **`-p`** | **显示提示信息**。在等待输入前先打印一段文字。 | `read -p "请输入名字: " name` |
| **`-s`** | **静默模式**。输入时不显示字符（常用于输入密码）。 | `read -s -p "密码: " password` |
| **`-t`** | **设置超时**。超过指定秒数未输入则退出，返回非零状态。 | `read -t 5 -p "5秒内输入: " val` |
| **`-n`** | **限制字符数**。读取指定数量的字符后立即返回，无需按回车。 | `read -n 1 -p "确认吗(y/n)? " choice` |
| **`-r`** | **禁止转义**。不对反斜杠 `\` 进行转义处理（**脚本编程建议必选**）。 | `read -r line` |
| **`-a`** | **读入数组**。将输入分割并存入一个索引数组中。 | `read -a my_array` |
| **`-d`** | **指定结束符**。默认以回车结束，可用此选项改为其他字符。 | `read -d ":" val` (读到冒号结束) |

---

### 3. 核心机制：IFS (Internal Field Separator)
`read` 命令拆分单词的行为受全局变量 `IFS` 的控制。默认情况下，`IFS` 包含空格、制表符和换行符。

**示例：修改分隔符读取 `/etc/passwd` 的一行**
```bash
# 使用冒号作为分隔符读取信息
IFS=":" read -r user pass uid gid comment home shell <<< "root:x:0:0:root:/root:/bin/bash"
echo "用户名: $user, 家目录: $home"
```

---

### 4. 常见用法示例

#### (1) 获取用户输入
```bash
#!/bin/bash
read -p "请输入您的账号: " username
read -s -p "请输入您的密码: " password
echo -e "\n欢迎，$username！"
```

#### (2) 逐行读取文件内容（最常用模式）
在脚本处理文件时，通常配合 `while` 循环使用 `-r` 选项：
```bash
#!/bin/bash
while read -r line; do
    echo "正在处理: $line"
done < "test.txt"
```

#### (3) 限制输入并自动继续
```bash
# 用户只需按下一个键，脚本就会继续，无需回车
read -n 1 -p "按任意键继续..."
```

---

### 5. 注意事项
1.  **`-r` 选项建议总是加上**：如果不加 `-r`，输入中的反斜杠 `\` 会被当做转义符处理（例如输入 `a\b` 最终变量会得到 `ab`）。为了保证数据的“原汁原味”，`read -r` 是最佳实践。
2.  **管道中的 read**：如果你使用 `echo "hi" | read x`，你会发现 `$x` 是空的。这是因为管道会产生一个**子 Shell**，`read` 在子 Shell 中修改了变量，但无法影响当前主 Shell。
    *   **解决方法**：使用 *Here Strings*：`read x <<< "hi"` 或使用 *Process Substitution*。