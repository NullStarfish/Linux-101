Shell脚本中的括号确实让人困惑！我来详细解释每种括号的区别：

## 1. **单方括号 `[ ]`**（test命令）

### 基本概念
```bash
# [ 实际上是 test 命令的别名
[ condition ]   # 等价于 test condition

# 必须注意空格！
[ -f file ]     # 正确
[-f file]       # 错误！没有空格
```

### 常用测试
```bash
# 文件测试
[ -f file ]      # 文件存在且是普通文件
[ -d dir ]       # 目录存在
[ -e path ]      # 文件/目录存在
[ -r file ]      # 文件可读
[ -w file ]      # 文件可写
[ -x file ]      # 文件可执行

# 字符串测试
[ -z "$str" ]    # 字符串为空
[ -n "$str" ]    # 字符串非空
[ "$str1" = "$str2" ]   # 字符串相等
[ "$str1" != "$str2" ]  # 字符串不等

# 数值比较（使用特殊运算符）
[ "$a" -eq "$b" ]    # 等于 equal
[ "$a" -ne "$b" ]    # 不等于 not equal
[ "$a" -lt "$b" ]    # 小于 less than
[ "$a" -le "$b" ]    # 小于等于 less or equal
[ "$a" -gt "$b" ]    # 大于 greater than
[ "$a" -ge "$b" ]    # 大于等于 greater or equal

# 逻辑运算
[ ! condition ]             # 非
[ condition1 -a condition2 ] # 与 (and)
[ condition1 -o condition2 ] # 或 (or)
```

## 2. **双方括号 `[[ ]]`**（bash扩展test）

### 更强大，更安全
```bash
# 只在bash/zsh等现代shell中可用
# 功能更丰富，语法更自然
```

### 优势对比
```bash
# 1. 字符串比较不需要引号（更安全）
[[ $var == pattern ]]     # 不需要引号也不会出错
[ "$var" = pattern ]      # 需要引号

# 2. 支持模式匹配
[[ $file == *.txt ]]      # 通配符匹配
[[ $file =~ ^[a-z]+$ ]]   # 正则表达式匹配

# 3. 逻辑运算符更直观
[[ condition1 && condition2 ]]  # 使用 && 而不是 -a
[[ condition1 || condition2 ]]  # 使用 || 而不是 -o
[[ ! condition ]]               # 使用 !

# 4. 字符串比较不需要转义
[[ $str1 < $str2 ]]       # 字典序比较
[[ $str1 > $str2 ]]

# 5. 自动处理未定义变量
unset var
[[ -z $var ]]             # 不会报错
[ -z "$var" ]             # 需要引号，否则会报错
```

### 示例对比
```bash
# 检查文件扩展名
file="test.txt"
[ "$file" == *.txt ]      # 错误：字面比较 "*" ".txt"
[[ $file == *.txt ]]      # 正确：模式匹配

# 正则匹配
email="user@example.com"
[[ $email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]

# 组合条件
if [[ -f "$file" && -r "$file" && $size -gt 0 ]]; then
    echo "可读的非空文件"
fi
```

## 3. **圆括号 `( )`**（子shell）

### 创建子shell执行
```bash
# 在子shell中执行命令
(cd /tmp && ls)  # 改变目录只在子shell中有效
pwd              # 还在原目录

# 并行执行
(date; sleep 2; date) &  # 后台运行子shell

# 命令分组（但更常用花括号）
( command1; command2 ) > output.txt

# 初始化数组
arr=(apple banana cherry)
echo ${arr[1]}  # banana
```

### 数组操作
```bash
# 创建数组
fruits=("apple" "banana" "cherry")

# 访问数组
echo ${fruits[0]}     # apple
echo ${fruits[@]}     # 所有元素
echo ${#fruits[@]}    # 数组长度

# 数组切片
echo ${fruits[@]:1:2} # banana cherry
```

## 4. **双圆括号 `(( ))`**（算术运算）

### 整数算术运算
```bash
# 替代 expr 和 $[]
(( result = 5 + 3 ))   # 赋值
echo $result          # 8

# 直接在条件中使用
if (( 5 > 3 )); then
    echo "5大于3"
fi

# C语言风格的运算符
(( a++ ))             # 自增
(( a-- ))             # 自减
(( a += 5 ))          # 复合赋值
```

### 算术比较
```bash
a=5
b=3

# 使用数学比较符
(( a > b ))           # true
(( a == 5 ))          # true
(( a != b ))          # true

# 复杂的数学表达式
(( result = (a + b) * 2 ))
```

### 在if/while中使用
```bash
# 计数器
count=0
while (( count < 5 )); do
    echo "Count: $count"
    (( count++ ))
done

# for循环的C风格
for (( i=0; i<10; i++ )); do
    echo "i=$i"
done
```

## 5. **花括号 `{ }`**（命令分组）

### 当前shell执行
```bash
# 不同于圆括号：在当前shell执行
{ cd /tmp; ls; }  # 改变目录会影响当前shell

# 必须有空格和分号
{ echo "start"; date; } > log.txt  # 正确
{echo "start"; date;} > log.txt    # 错误！花括号后必须有空格

# 重定向整个组
{
    echo "=== Start ==="
    ls -l
    echo "=== End ==="
} > output.txt
```

### 序列生成
```bash
# 数字序列
echo {1..5}        # 1 2 3 4 5
echo {5..1}        # 5 4 3 2 1
echo {01..10}      # 01 02 03 ... 10

# 字母序列
echo {a..e}        # a b c d e
echo {A..E}        # A B C D E

# 组合扩展
echo {a,b,c}{1,2}  # a1 a2 b1 b2 c1 c2
```

### 变量扩展
```bash
# 避免歧义
var="world"
echo "Hello$var"      # 正确：Hello world
echo "Hello${var}!"   # 正确：Hello world!
echo "Hello$var!"     # 错误：尝试找变量var!

# 默认值
${var:-default}       # 如果var未设置，使用default
${var:=default}       # 如果var未设置，设置var为default
${var:?error}         # 如果var未设置，显示错误
${var:+alternate}     # 如果var已设置，使用alternate

# 子字符串
${var:start:length}   # 从start开始取length个字符
${var#pattern}        # 删除最短匹配前缀
${var##pattern}       # 删除最长匹配前缀
${var%pattern}        # 删除最短匹配后缀
${var%%pattern}       # 删除最长匹配后缀
```

## 快速对比表

| 括号类型 | 用途 | 示例 | 特点 |
|---------|------|------|------|
| `[ ]` | 条件测试 | `[ -f file ]` | 兼容性好，需要引号 |
| `[[ ]]` | 扩展测试 | `[[ $var == *.txt ]]` | 更安全，功能多 |
| `( )` | 子shell | `(cd dir && ls)` | 创建新进程 |
| `(( ))` | 算术运算 | `(( a = b + 1 ))` | 整数运算 |
| `{ }` | 命令分组 | `{ cmd1; cmd2; }` | 当前shell执行 |

## 实际脚本示例

```bash
#!/bin/bash

# 综合使用示例

# 1. 检查参数
if [[ $# -eq 0 ]]; then
    echo "用法: $0 <文件>"
    exit 1
fi

file="$1"

# 2. 检查文件是否存在且可读
if [[ ! -f "$file" || ! -r "$file" ]]; then
    echo "错误：文件不存在或不可读"
    exit 2
fi

# 3. 统计行数、词数
{
    echo "=== 文件分析 ==="
    wc -l "$file"
    wc -w "$file"
} > report.txt

# 4. 算术计算文件大小
size=$(wc -c < "$file")
if (( size > 1000 )); then
    echo "文件较大: $size 字节"
    
    # 5. 处理大文件（前100行）
    {
        head -n 100 "$file"
        echo "... [省略] ..."
        tail -n 100 "$file"
    } > preview.txt
fi

# 6. 数组操作
lines=($(head -n 10 "$file"))
echo "前10行的第一个单词: ${lines[0]}"

# 7. 序列生成创建测试文件
for i in {1..5}; do
    echo "这是测试文件 $i" > "test$i.txt"
done
```

## 最佳实践建议

1. **bash脚本优先用 `[[ ]]`**：更安全，功能更强
2. **POSIX兼容用 `[ ]`**：需要兼容/bin/sh时使用
3. **算术运算用 `(( ))`**：比 `expr` 和 `$[]` 更好
4. **小心空格**：`[` 和 `[[` 后必须有空格
5. **变量加引号**：在 `[ ]` 中一定要加，在 `[[ ]]` 中可不加
6. **子shell用 `( )`**，当前shell分组用 `{ }`

记住：**`[[` 是关键字，`[` 是命令**。这是最本质的区别！