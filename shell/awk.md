`awk` 是 Linux/Unix 下功能极其强大的文本处理工具，它不仅是一个命令，更是一门完整的编程语言。

它的核心思想是：**按行读取文本，根据指定的“匹配模式”对符合条件的行执行“处理动作”。**

### 1. 基本语法
```bash
awk 'pattern { action }' file
```
- **pattern**：匹配模式，比如“某列大于100”或“包含关键词”。
- **action**：处理动作，最常用的是 `print`。
- **file**：待处理的文件名。

---

### 2. 常用内置变量
学习 `awk` 之前，先记住这几个“暗号”：
- `$0`：代表整行内容。
- `$1`, `$2`, `$n`：代表第 1、2、n 个字段（默认以空格或制表符分隔）。
- **NR**：当前处理的是第几行（Number of Record）。
- **NF**：当前行一共有多少个字段（Number of Field）。

---

### 3. 简单实用案例

假设我们有一个文件 `score.txt`，内容如下：
```text
ID   Name    Math  English
101  Alice   90    85
102  Bob     75    80
103  Charlie 60    70
```

#### ① 只打印特定列
打印名字和数学成绩：
```bash
awk '{print $2, $3}' score.txt
```

#### ② 根据条件过滤行
打印数学成绩大于 80 的同学姓名：
```bash
awk '$3 > 80 {print $2}' score.txt
```

#### ③ 搜索关键词
打印包含 "Alice" 的整行信息：
```bash
awk '/Alice/ {print $0}' score.txt
```

#### ④ 指定分隔符 (重要)
如果你的文件是以冒号分隔的（比如 `/etc/passwd`），使用 `-F` 参数：
```bash
awk -F ":" '{print $1}' /etc/passwd
```

#### ⑤ 显示行号和列数
```bash
awk '{print "第" NR "行有" NF "列内容：" $0}' score.txt
```

---

### 4. 进阶一点：BEGIN 和 END 块
- **BEGIN**：在处理文本**之前**执行（通常用于打印表头）。
- **END**：在处理完所有行**之后**执行（通常用于统计）。

**示例：计算数学平均分**
```bash
awk 'NR > 1 {sum += $3; count++} END {print "数学平均分是：" sum/count}' score.txt
```
*解释：`NR > 1` 跳过表头；每一行把第三列加到 `sum` 里；最后打印结果。*

---

### 5. 什么时候用 awk？
- 当你需要**提取日志里的某几列**时。
- 当你需要对数据进行**简单的数学运算**（加总、平均）时。
- 当你需要**格式化输出**文本时。

**一句话总结：**
如果你只想找包含某个词的行，用 `grep`；如果你想把那一行的第 2 列提出来并算个总和，用 `awk`。




在 `awk` 中，正则表达式（Regex）是其灵魂。掌握了正则，你就从“只会提数据的搬运工”变成了“能对文本进行精雕细琢的工匠”。

我们可以从 **“匹配谁”**、**“怎么配”** 和 **“匹配后干什么”** 三个维度来深入。

---

### 1. 核心操作符：`~` 和 `!~`
在基础篇中，我们直接用 `/pattern/` 匹配整行。但更高级的用法是用这两个符号针对**特定列**：
- **`~`**：表示“匹配”。
- **`!~`**：表示“不匹配”。

**例子：** 只有当第 2 列（名字）以 "A" 开头时，才打印该行：
```bash
awk '$2 ~ /^A/ {print $0}' score.txt
```

---

### 2. 常用正则元字符（awk 版）
`awk` 使用的是**扩展正则表达式（ERE）**，常见的符号如下：

| 符号 | 含义 | 示例 |
| :--- | :--- | :--- |
| **`^`** | 匹配行首/字段首 | `^root` 匹配以 root 开头的字符串 |
| **`$`** | 匹配行尾/字段尾 | `log$` 匹配以 log 结尾的字符串 |
| **`.`** | 匹配任意单个字符 | `a.c` 匹配 abc, a1c, a#c |
| **`*`** | 匹配前面的字符 0 次或多次 | `ab*` 匹配 a, ab, abb... |
| **`+`** | 匹配前面的字符 1 次或多次 | `ab+` 匹配 ab, abb...（不匹配 a） |
| **`?`** | 匹配前面的字符 0 次或 1 次 | `apples?` 匹配 apple 或 apples |
| **`[ ]`** | 字符集合，匹配其中之一 | `[0-9]` 匹配任意数字；`[a-z]` 匹配字母 |
| **`[^ ]`** | 取反集合，不匹配其中字符 | `[^0-9]` 匹配所有非数字字符 |
| **`\|`** | 逻辑“或” | `(Alice\|Bob)` 匹配 Alice 或 Bob |

---

### 3. 实战案例：让匹配更精准

#### ① 匹配特定格式（如手机号/数字）
假设有一个通讯录，筛选出所有第 3 列是纯 3 位数字（如分机号）的行：
```bash
awk '$3 ~ /^[0-9]{3}$/' info.txt
```
*注：有些 awk 版本需要加 `--re-interval` 参数来开启 `{n}` 这种次数匹配。*

#### ② 逻辑组合匹配
打印第 2 列包含 "Li" **或者** 第 3 列大于 80 的行：
```bash
awk '$2 ~ /Li/ || $3 > 80' score.txt
```

---

### 4. 忽略大小写
`awk` 默认是区分大小写的。如果想忽略大小写，有两种常用方法：

- **方法 A：使用 `tolower()` 函数**（最通用）
  将字段先转为小写再匹配：
  ```bash
  awk 'tolower($2) ~ /alice/' score.txt
  ```
- **方法 B：使用 `IGNORECASE` 变量**（仅限 gawk/GNU awk）
  ```bash
  awk 'BEGIN{IGNORECASE=1} $2 ~ /alice/' score.txt
  ```

---

### 5. 进阶：正则替换 `gsub`
正则不仅能用来“找”，还能用来“改”。`gsub` 函数可以根据正则替换文本。
**语法：** `gsub(/正则/, "替换成什么", 哪一列)`

**例子：** 把文件里所有的数学成绩（第 3 列）中，凡是 60 分以下的都标记为 "FAIL"：
```bash
awk '{if($3 < 60) gsub(/[0-9]+/, "FAIL", $3); print $0}' score.txt
```
*解释：`gsub(/[0-9]+/, "FAIL", $3)` 会在第 3 列中查找数字并替换。*

---

### 6. 什么时候该出招？（总结）

| 如果你需要... | 请使用... |
| :--- | :--- |
| 查找包含某个词的行 | `awk '/pattern/'` |
| 查找**第 N 列**符合某种模式的行 | `awk '$N ~ /pattern/'` |
| 排除掉符合某种模式的行 | `awk '$N !~ /pattern/'` |
| 根据模式动态修改内容 | `awk '{gsub(/pattern/, "new", $N); print}'` |

**练习建议：**
试着用 `awk` 处理一下系统的 `df -h` 输出，比如：只打印磁盘使用率（带有 `%` 的那一列）超过 80% 的行。这会让你对 `awk` 的正则处理非常有体感！